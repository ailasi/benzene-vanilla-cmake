""" Plays the tournament."""

import random
import time

from game import Game
from game_player import GamePlayer
from program import Program

"""Stores summary information about each game played."""


class ResultsFile:
    def __init__(self, name, header):
        self._name = name
        self._was_existing = self._check_existing()
        self._game_index = 0

        if self._was_existing:
            self._last_index = self._find_last_index()
            self._print_time_stamp()
        else:
            self._last_index = -1
            self._print_header(header)

    def add_result(self, current_round, opening, black_name, white_name,
                   result_black, result_white, game_len,
                   elapsed_black, elapsed_white,
                   error, error_message):

        self._last_index += 1
        f = open(self._name, "a")
        f.write("%04i\t%i\t%s\t%s\t%s\t%s\t%s\t%i\t%.1f\t%.1f\t%s\t%s\n"
                % (self._last_index, int(current_round), opening,
                   black_name, white_name, result_black, result_white,
                   game_len, elapsed_black, elapsed_white,
                   error, error_message))
        f.close()

    def was_existing(self):
        return self._was_existing

    def clear(self):
        f = open(self._name, "w")
        f.close()
        self._print_header("")
        self._game_index = -1
        self._was_existing = 0

    def get_last_index(self):
        return self._last_index

    def _check_existing(self):
        try:
            f = open(self._name, "r")
        except IOError:
            return 0
        f.close()
        return 1

    def _find_last_index(self):
        f = open(self._name, "r")
        last = -1
        line = f.readline()
        while line != "":
            if line[0] != "#":
                array = str.split(line, "\t")
                last = int(array[0])
            line = f.readline()
        f.close()
        return last

    def _print_header(self, info_lines):
        f = open(self._name, "w")
        f.write("# Game results file generated by main.py.\n"
                "#\n")
        for line in info_lines:
            f.write("# %s\n" % line)
        f.write("#\n"
                "# GAME\tROUND\tOPENING\tBLACK\tWHITE\tRES_B\tRES_W\tLENGTH\tTIME_B\tTIME_W\tERR\tERR_MSG\n"
                "#\n")
        f.close()
        self._print_time_stamp()

    def _print_time_stamp(self):
        f = open(self._name, "a")
        time_stamp = time.strftime("%Y-%m-%d %X %Z", time.localtime())
        f.write("# Date: " + time_stamp + "\n")
        f.close()


def handle_result(swapped, result):
    ret = result
    if swapped:
        if result[0:2] == 'B+':
            ret = 'W+' + result[2:]
        elif result[0:2] == 'W+':
            ret = 'B+' + result[2:]
    return ret


class Tournament:
    def __init__(self,
                 p1name, p1cmd, p2name, p2cmd, size, rounds, outdir,
                 openings, verbose):

        self._p1name = p1name
        self._p1cmd = p1cmd
        self._p2name = p2name
        self._p2cmd = p2cmd
        self._size = size
        self._rounds = rounds
        self._outdir = outdir
        self._verbose = verbose
        self._openings = []

        info = ["p1name: " + p1name,
                "p1cmd: " + p1cmd,
                "p2name: " + p2name,
                "p2cmd: " + p2cmd,
                "Board size: " + repr(size),
                "Rounds: " + repr(rounds),
                "Openings: " + openings,
                "Directory: " + outdir,
                "Start Date: "
                + time.strftime("%Y-%m-%d %X %Z", time.localtime())]

        if verbose:
            for line in info:
                print(line)

        self._results_file = ResultsFile(outdir + "/results", info)
        self.load_openings(openings)

    def load_openings(self, openings):
        assert False

    def play_tournament(self):
        assert False

    def play_game(self, game_index, current_round,
                  black_name, black_cmd, white_name, white_cmd,
                  opening, verbose):
        if verbose:
            print()
            print("===========================================================")
            print("Game ", game_index)
            print("===========================================================")

        b_cmd = "nice " + black_cmd + " --seed %SRAND" + " --logfile-name " + self._outdir + \
                "/" + black_name + "-" + str(game_index) + ".log"
        w_cmd = "nice " + white_cmd + " --seed %SRAND" + " --logfile-name " + self._outdir + \
                "/" + white_name + "-" + str(game_index) + ".log"
        b_log_name = self._outdir + "/" + black_name + "-" + str(game_index) + "-stderr.log"
        w_log_name = self._outdir + "/" + white_name + "-" + str(game_index) + "-stderr.log"
        black = Program("B", black_cmd, b_log_name, verbose)
        white = Program("W", white_cmd, w_log_name, verbose)

        result_black = "?"
        result_white = "?"

        error = 0
        error_message = ""

        game = Game()  # Just a temporary.
        game_player = GamePlayer(black, white, self._size)

        try:
            game = game_player.play(opening, verbose)
            swapped = game.played_swap()
            result_black = handle_result(swapped, black.get_result())
            result_white = handle_result(swapped, white.get_result())
        except GamePlayer.Error:
            error = 1
            error_message = game_player.get_error_message()
        except Program.Died:
            error = 1
            error_message = "program died"

        name = "%s/%04i" % (self._outdir, game_index)

        result = "?"
        if result_black == result_white:
            result = result_black
        game.set_result(result)

        self._results_file.add_result(current_round, opening,
                                      black_name, white_name,
                                      result_black, result_white,
                                      # -1 so we don't count "resign" as a move
                                      game.get_length() - 1,
                                      game.get_elapsed("black"),
                                      game.get_elapsed("white"),
                                      error, error_message)

        game_player.save(name + ".sgf", name, result_black, result_white)

        if error:
            print("Error: Game", game_index)

        for program in [black, white]:
            try:
                program.send_command("quit")
            except Program.Died:
                pass

        return game


""" Plays a standard iterative tournament.

For each round, each program takes each opening as black."""


class IterativeTournament(Tournament):
    def load_openings(self, openings):
        if openings != '':
            self._openings = []
            f = open(openings, 'r')
            lines = f.readlines()
            f.close()
            for line in lines:
                self._openings.append(str.strip(line))

    def play_tournament(self):
        games_per_round = 2 * len(self._openings)
        first = self._results_file.get_last_index() + 1
        results = {
            "W+": 0,
            "B+": 0,
        }
        for i in range(first, self._rounds * games_per_round):
            current_round = i / games_per_round
            game_in_round = i % games_per_round
            opening_index = int(game_in_round / 2)

            opening = self._openings[opening_index]

            if (i % 2) == 0:
                current_result = self.play_game(i, current_round,
                                                self._p1name, self._p1cmd,
                                                self._p2name, self._p2cmd,
                                                opening, self._verbose).get_result()
            else:
                current_result = self.play_game(i, current_round,
                                                self._p2name, self._p2cmd,
                                                self._p1name, self._p1cmd,
                                                opening, self._verbose).get_result()
            results[current_result] += 1

        print(results)


"""Plays a random tournament:

For each round, pick a random opening (weighted), then:
if round is even, program one takes black, otherwise
program two takes black."""


class RandomTournament(Tournament):
    def __init__(self,
                 p1name, p1cmd, p2name, p2cmd, size, rounds, outdir,
                 openings, verbose):
        super().__init__(p1name, p1cmd, p2name, p2cmd, size, rounds, outdir, openings, verbose)
        self._max_weight = None

    def load_openings(self, openings):
        if openings != '':
            self._openings = []
            f = open(openings, 'r')
            lines = f.readlines()
            f.close()
            cur_sum = 0
            for line in lines:
                stripped = line.strip()
                array = stripped.split(' ')
                cur_sum = cur_sum + float(array[0])
                moves = stripped[len(array[0]):].strip()
                self._openings.append([cur_sum, moves])
            self._max_weight = cur_sum
            print(self._openings)

    def pick_opening(self):
        random_weight = random.random() * self._max_weight
        for i in range(len(self._openings)):
            if random_weight < self._openings[i][0]:
                return self._openings[i][1]
        assert False

    def play_tournament(self):
        first = self._results_file.get_last_index() + 1
        for currentRound in range(first, self._rounds):
            opening = self.pick_opening()
            if (currentRound % 2) == 0:
                self.play_game(currentRound, currentRound,
                               self._p1name, self._p1cmd,
                               self._p2name, self._p2cmd,
                               opening, self._verbose)
            else:
                self.play_game(currentRound, currentRound,
                               self._p2name, self._p2cmd,
                               self._p1name, self._p1cmd,
                               opening, self._verbose)
